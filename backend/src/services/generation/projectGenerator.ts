export interface ProjectFile {
  path: string
  content: string
}

export function generateProjectFiles(contractCode: string, projectName: string = 'contract', description?: string, category?: string): ProjectFile[] {
  const files: ProjectFile[] = []

  // Cargo.toml
  files.push({
    path: 'Cargo.toml',
    content: generateCargoToml(projectName)
  })

  // src/lib.rs
  files.push({
    path: 'src/lib.rs',
    content: contractCode
  })

  // meta/Cargo.toml
  files.push({
    path: 'meta/Cargo.toml',
    content: generateMetaCargoToml(projectName)
  })

  // meta/src/main.rs
  files.push({
    path: 'meta/src/main.rs',
    content: generateMetaMain()
  })

  // README.md
  files.push({
    path: 'README.md',
    content: generateReadme(projectName, contractCode, description, category)
  })

  // .gitignore
  files.push({
    path: '.gitignore',
    content: generateGitignore()
  })

  return files
}

function generateCargoToml(projectName: string): string {
  return `[package]
name = "${projectName}"
version = "0.1.0"
authors = ["AI Contract Generator"]
edition = "2021"
publish = false

[lib]
path = "src/lib.rs"

[dependencies.multiversx-sc]
version = "0.64.0"

[dev-dependencies.multiversx-sc-scenario]
version = "0.64.0"

[dev-dependencies.multiversx-sc-meta]
version = "0.64.0"
`
}

function generateMetaCargoToml(projectName: string): string {
  return `[package]
name = "${projectName}-meta"
version = "0.1.0"
authors = ["AI Contract Generator"]
edition = "2021"
publish = false

[dependencies.multiversx-sc-meta]
version = "0.64.0"

[dependencies.${projectName}]
path = ".."
`
}

function generateMetaMain(): string {
  return `fn main() {
    multiversx_sc_meta::cli_main::<contract::AbiProvider>();
}
`
}

function generateReadme(projectName: string, contractCode: string, description?: string, category?: string): string {
  // Extract contract info from code
  const endpoints = extractEndpoints(contractCode)
  const viewFunctions = extractViewFunctions(contractCode)
  const events = extractEvents(contractCode)
  const storage = extractStorage(contractCode)
  
  return `# ${projectName}

AI-generated MultiversX smart contract.

## Contract Description

${description || 'Smart contract generated based on custom requirements.'}

**Category**: ${category || 'General'}

## Key Features

This contract implements:
${endpoints.length > 0 ? endpoints.map(e => `- **${e}**: Endpoint function`).join('\n') : '- Custom business logic'}

## Contract Functions

### Endpoints (Write Operations)
${endpoints.length > 0 ? endpoints.map(e => `- \`${e}\``).join('\n') : 'See src/lib.rs for available endpoints'}

### View Functions (Read-only)
${viewFunctions.length > 0 ? viewFunctions.map(v => `- \`${v}\``).join('\n') : 'See src/lib.rs for view functions'}

### Events
${events.length > 0 ? events.map(ev => `- \`${ev}\``).join('\n') : 'See src/lib.rs for events'}

### Storage
${storage.length > 0 ? storage.map(s => `- \`${s}\``).join('\n') : 'See src/lib.rs for storage mappers'}

## Project Structure

\`\`\`
${projectName}/
├── src/
│   └── lib.rs          # Main contract code
├── meta/
│   ├── Cargo.toml      # Meta crate configuration
│   └── src/main.rs     # Build script
├── Cargo.toml          # Project dependencies
└── README.md           # This file
\`\`\`

## Build

\`\`\`bash
mxpy contract build
\`\`\`

This generates:
- \`output/contract.wasm\` - Deployable bytecode
- \`output/contract.abi.json\` - Contract interface

## Test

\`\`\`bash
mxpy contract test
\`\`\`

## Deploy

### Devnet
\`\`\`bash
mxpy contract deploy \\
  --bytecode=output/contract.wasm \\
  --pem=wallet.pem \\
  --gas-limit=60000000 \\
  --proxy=https://devnet-gateway.multiversx.com \\
  --chain=D \\
  --recall-nonce \\
  --send
\`\`\`

### Mainnet
\`\`\`bash
mxpy contract deploy \\
  --bytecode=output/contract.wasm \\
  --pem=wallet.pem \\
  --gas-limit=60000000 \\
  --proxy=https://gateway.multiversx.com \\
  --chain=1 \\
  --recall-nonce \\
  --send
\`\`\`

## Interact

After deployment, interact with your contract:

\`\`\`bash
# Call an endpoint
mxpy contract call <CONTRACT_ADDRESS> \\
  --function=<FUNCTION_NAME> \\
  --pem=wallet.pem \\
  --gas-limit=5000000 \\
  --proxy=https://devnet-gateway.multiversx.com \\
  --chain=D \\
  --recall-nonce \\
  --send

# Query a view function
mxpy contract query <CONTRACT_ADDRESS> \\
  --function=<VIEW_FUNCTION_NAME> \\
  --proxy=https://devnet-gateway.multiversx.com
\`\`\`

## Resources

- [MultiversX Docs](https://docs.multiversx.com)
- [Smart Contract Examples](https://github.com/multiversx/mx-sdk-rs/tree/master/contracts/examples)
- [MultiversX SDK](https://github.com/multiversx/mx-sdk-rs)

## Security Notes

- **Audit**: Always audit contracts before mainnet deployment
- **Test**: Thoroughly test on devnet first
- **Access Control**: Review owner-only functions
- **Upgrades**: Consider upgrade strategy

---

**Generated by AI Contract Generator**
`
}

// Helper functions to extract contract info
function extractEndpoints(code: string): string[] {
  const regex = /#\[endpoint(?:\([^)]*\))?\]\s*fn\s+(\w+)/g
  const matches = [...code.matchAll(regex)]
  return matches.map(m => m[1]).filter(name => name !== 'init' && name !== 'upgrade')
}

function extractViewFunctions(code: string): string[] {
  const regex = /#\[view(?:\([^)]*\))?\]\s*fn\s+(\w+)/g
  const matches = [...code.matchAll(regex)]
  return matches.map(m => m[1])
}

function extractEvents(code: string): string[] {
  const regex = /#\[event\(["']([^"']+)["']\)\]/g
  const matches = [...code.matchAll(regex)]
  return matches.map(m => m[1])
}

function extractStorage(code: string): string[] {
  const regex = /#\[storage_mapper\(["']([^"']+)["']\)\]/g
  const matches = [...code.matchAll(regex)]
  return matches.map(m => m[1])
}

function generateGitignore(): string {
  return `# Rust
target/
output/
*.wasm
*.abi.json

# IDE
.vscode/
.idea/
*.swp

# OS
.DS_Store
Thumbs.db

# Deployment
wallet.pem
*.pem
`
}
